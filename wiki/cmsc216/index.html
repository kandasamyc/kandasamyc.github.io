<!doctype html><html lang=en><head><title>CMSC216 :: Kandasamy Chokkalingam</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Notes from UMD's CMSC216 class"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://www.kandasamyc.com/wiki/cmsc216/><link rel=stylesheet href=https://www.kandasamyc.com/assets/style.css><link rel=stylesheet href=https://www.kandasamyc.com/assets/green.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css integrity=sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js integrity=sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><link rel=apple-touch-icon href=https://www.kandasamyc.com/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://www.kandasamyc.com/img/favicon/green.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="CMSC216"><meta property="og:description" content="Notes from UMD's CMSC216 class"><meta property="og:url" content="https://www.kandasamyc.com/wiki/cmsc216/"><meta property="og:site_name" content="Kandasamy Chokkalingam"><meta property="og:image" content="https://www.kandasamyc.com/img/favicon/green.png"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2022-01-26 00:00:00 +0000 UTC"></head><body class=green><div class="container center"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>Kandasamy Chokkalingam</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/>About</a></li><li><a href=/#contact>Contact</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/>About</a></li><li><a href=/#contact>Contact</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://www.kandasamyc.com/wiki/cmsc216/>CMSC216</a></h1><div class=post-meta><span class=post-date>2022-01-26
</span><span class=post-author>:: [ksam]</span></div><div class=post-content><div><h2 id=c-syntax>C Syntax<a href=#c-syntax class=hanchor arialabel=Anchor>&#8983;</a></h2><h3 id=preprocessor-directives>Preprocessor Directives<a href=#preprocessor-directives class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Code at the beginning of a file that starts with a #. This is run before compilation.</p><div class=collapsable-code><input id=615894723 type=checkbox checked>
<label for=615894723><span class=collapsable-code__language>c</span>
<span class=collapsable-code__title>Preprocessor Directives</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class="language-c line-numbers"><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#define MAX_COLS 20 /* max # of columns to process */
#define MAX_INPUT 1000</code></pre></div><p><code>#define</code> defines a constant value, <code>#include</code> includes another file&rsquo;s declarations.</p><h3 id=main-function>Main Function<a href=#main-function class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>Returns an int, takes no arguments (so void)</li></ul><div class=collapsable-code><input id=592614738 type=checkbox checked>
<label for=592614738><span class=collapsable-code__language>c</span>
<span class=collapsable-code__title>Main Function</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class="language-c line-numbers"><code>int main(void){
    /* Some code */
    return 0;
}</code></pre></div><h3 id=prototypes>Prototypes<a href=#prototypes class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>The first function &ldquo;declaration&rdquo;</li><li>No body</li><li>Placed at the top to allow the compiler to do proper type checking</li></ul><h2 id=basic-concepts>Basic Concepts<a href=#basic-concepts class=hanchor arialabel=Anchor>&#8983;</a></h2><h3 id=environments>Environments<a href=#environments class=hanchor arialabel=Anchor>&#8983;</a></h3><h4 id=translation-environment>Translation Environment<a href=#translation-environment class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li>Source code get compiled into object code</li><li>Which then gets linked with other object code by the linker to form a single executable</li></ul><h4 id=execution-environment>Execution Environment<a href=#execution-environment class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li>The code is then excuted by loading it into memory (an os is not neccessary but usually used), setting it up, running it, and terminating it by returning <a href=/wiki/cmsc216/#main-function>main&rsquo;s</a> error code.</li></ul><h3 id=lexical-rules>Lexical Rules<a href=#lexical-rules class=hanchor arialabel=Anchor>&#8983;</a></h3><h4 id=trigraphs>Trigraphs<a href=#trigraphs class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li>A 3-sequence of a characters that may not be easily typeable</li></ul><h4 id=comments>Comments<a href=#comments class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li>Begin with <code>/*</code> and end with <code>*/</code></li><li>Can be multiple lines, by not nested<ul><li>If they&rsquo;re multiple lines, they get everything on those lines</li></ul></li></ul><h3 id=declaration>Declaration<a href=#declaration class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>A declaration causes memory to be reserved for the variable</li><li>There is no extra instantiation</li><li>If variables are uninitialized they&rsquo;ll just have garbage values</li></ul><h3 id=expression-and-assignment>Expression and assignment<a href=#expression-and-assignment class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>Assignment returns the value the variable was assigned</li><li>An expression can be a simple statement, its just not useful unless it has a side effect</li></ul><h4 id=side-effect>Side Effect<a href=#side-effect class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li>A change in program state</li></ul><h3 id=booleans-in-c>Booleans in C<a href=#booleans-in-c class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>There is no boolean type, 0 is false, non-zero is true</li></ul><h3 id=arithmetic-conversion>Arithmetic Conversion<a href=#arithmetic-conversion class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>Both <code>char</code> and <code>short</code> types are promoted to <code>int</code> types when doing math</li><li>If arithmetic operations are performed with different <code>int</code> types, the smaller type is promoted to be the higher type</li></ul><h2 id=standard-library>Standard Library<a href=#standard-library class=hanchor arialabel=Anchor>&#8983;</a></h2><h3 id=stdio>stdio<a href=#stdio class=hanchor arialabel=Anchor>&#8983;</a></h3><h4 id=printf>printf<a href=#printf class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li><code>printf</code> takes in a character string with 0 or more format specifiers, if any are present, it also takes in that many other values after the string</li><li>They contain escape sequences, format specifiers, and normal characters</li><li>Format specifiers include<ul><li>%d for integers</li><li>%f for floats</li><li>%c for characters</li><li>%u for unsigned int decimal</li><li>%x for unsigned int hex</li><li>%o for unsigned int octal</li></ul></li><li>Padding can be done by adding the number of spaces to pad by before the specifier ("%4d")<ul><li>You can fill with 0s instead by adding a 0 beforehand ("%04d")</li></ul></li></ul><h4 id=scanf>scanf<a href=#scanf class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li><code>scanf</code> takes in a character string with 0 or more format specifiers, if any are present, it also takes in that many other variable pointers after the string</li><li>It takes in format specifiers and reads each one into its corresponding variable</li><li>If too few variables are put in, scanf will wait</li><li>It too many variables are put in, they will remain in the input</li><li>If the last data in the input has been read, scanf returns a special <code>EOF</code> value</li><li>Format specifiers include<ul><li>%d for integers</li><li>%f for floats</li><li>%c for characters</li></ul></li></ul><h4 id=feof>feof<a href=#feof class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li><code>feof(stdin)</code> will be true if the <strong>previous</strong> try to read didn&rsquo;t work because there was no more data</li><li>You must try to read something for <code>feof</code> to work</li></ul><h3 id=assert>assert<a href=#assert class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>If <code>assert()</code> argument is false, it will kill the program</li></ul><h3 id=stddef>stddef<a href=#stddef class=hanchor arialabel=Anchor>&#8983;</a></h3><h2 id=data>Data<a href=#data class=hanchor arialabel=Anchor>&#8983;</a></h2><h3 id=integers>Integers<a href=#integers class=hanchor arialabel=Anchor>&#8983;</a></h3><h4 id=values>Values<a href=#values class=hanchor arialabel=Anchor>&#8983;</a></h4><p><code>short</code> &lt;= <code>int</code> &lt;= <code>long</code></p><table><thead><tr><th>Type</th><th>Signedness</th><th>Max Start</th><th>Min End</th></tr></thead><tbody><tr><td>int</td><td>signed</td><td>-32767</td><td>32767</td></tr><tr><td>unsigned int</td><td>unsigned</td><td>0</td><td>65535</td></tr><tr><td>short int</td><td>unsigned</td><td>-32767</td><td>32767</td></tr><tr><td>unsigned short int</td><td>signed</td><td>0</td><td>65535</td></tr><tr><td>long int</td><td>signed</td><td>-214783647</td><td>2147483647</td></tr><tr><td>unsigned long int</td><td>unsigned</td><td>0</td><td>4294967295</td></tr><tr><td>char</td><td>NA</td><td>0</td><td>127</td></tr><tr><td>signed char</td><td>signed</td><td>-127</td><td>127</td></tr><tr><td>unsigned char</td><td>unsigned</td><td>0</td><td>255</td></tr></tbody></table><h4 id=literals>Literals<a href=#literals class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li>Decimals</li><li>In octal when starting with a 0</li><li>In hex when starting with an 0x</li><li>Characters literals in single quotes</li></ul><h4 id=promotion>Promotion<a href=#promotion class=hanchor arialabel=Anchor>&#8983;</a></h4><h3 id=enumerated-type>Enumerated Type<a href=#enumerated-type class=hanchor arialabel=Anchor>&#8983;</a></h3><h4 id=values>Values<a href=#values class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li>Enums are stored as ints</li><li>The numbers after the name are optional</li></ul><div class=collapsable-code><input id=216354789 type=checkbox>
<label for=216354789><span class=collapsable-code__language>c</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-c><code>enum Jar_Type { CUP=8, PINT=16, QUART=32, HALF_GALLON=64, GALLON=128 };</code></pre></div><h3 id=floating-point>Floating-Point<a href=#floating-point class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>Have a decimal point <code>3.141</code></li><li>Have an exponent <code>1E10</code></li><li>Or both <code>6.023e23</code></li></ul><h3 id=pointers>Pointers<a href=#pointers class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>Every memory location has an address</li><li><strong>Pointer</strong> is another name for address</li><li><strong>Pointer Variable</strong> is a variable whose value is an address of a moeory location</li><li>There are no point constants because we can&rsquo;t predict where memory addresses will be</li><li>To declare a pointer, use the indirection operator before the variable<ul><li>The indirection operation gets the value at an address, so therefore the variable stores a pointer to an address with a value of the given type</li><li><code>int *a</code> is an in pointer</li><li>If you declare multiple on the same line, you need a <code>*</code> for each one</li><li>When initializing it on the same line, the value you give goes to the variable itself, not the pointer</li></ul></li></ul><h3 id=string>String<a href=#string class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>C has no string type, but there is a string literal</li><li>A string is a sequence of characters terminated by a <code>NUL</code> byte<ul><li>A sequence of zero characters is valid</li></ul></li></ul><h3 id=arrays>Arrays<a href=#arrays class=hanchor arialabel=Anchor>&#8983;</a></h3><h4 id=declaration>Declaration<a href=#declaration class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li>Like declaring any variable, but with square brackets after the name with a capacity value: <code>int values[20]</code></li><li>Array sizes must be constants at compile time, so literals or <a href=/wiki/cmsc216/#preprocessor-directives>symbolic constants</a></li></ul><h4 id=initialization>Initialization<a href=#initialization class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li>You can&rsquo;t assign variables to each other or compare entire arrays</li><li>You can initialize an array when you declare it by setting it equal to values in curly braces: <code>int values[20] = {1,2,3}</code><ul><li>This sets the first 3 items to 1,2, and 3 respectively and fills the others with 0</li><li>If you pass fewer, it fills the rest with 0s, but you need at least 1</li></ul></li></ul><h4 id=behavior>Behavior<a href=#behavior class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li>Array parameters don&rsquo;t take sizes (at least for one-dimensional arrays)</li><li>Arrays are passed by value but act like they&rsquo;re passed by reference, because of <a href=/wiki/cmsc216/#pointers>Pointers</a></li><li>Arrays don&rsquo;t keep track of their length</li><li>Accessing an invalid index won&rsquo;t be an error itself but can cause one by accessing or changing memory its not supposed to</li></ul><h3 id=typedef><code>Typedef</code><a href=#typedef class=hanchor arialabel=Anchor>&#8983;</a></h3><h3 id=scope>Scope<a href=#scope class=hanchor arialabel=Anchor>&#8983;</a></h3><h4 id=block-scope>Block Scope<a href=#block-scope class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li>Exists within the block</li><li>Have <a href=/wiki/cmsc216/#no-linkage>No Linkage</a></li></ul><h4 id=file-scope>File Scope<a href=#file-scope class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li>Exists within the whole file</li><li>Have <a href=/wiki/cmsc216/#external-linkage>External Linkage</a></li></ul><h4 id=shadowing>Shadowing<a href=#shadowing class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li>The variable with the narrowest scope will shadow the other(s)</li></ul><h3 id=linkage>Linkage<a href=#linkage class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>Determines if multiple instances of the same identifier refer to the same thing or not</li></ul><h4 id=no-linkage>No Linkage<a href=#no-linkage class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li>All occurrences are different</li></ul><h4 id=internal-linkage>Internal Linkage<a href=#internal-linkage class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li>All occurrences in a given file are the same</li></ul><h4 id=external-linkage>External Linkage<a href=#external-linkage class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li>All occurrences are the same</li></ul><h4 id=changing-linkage>Changing Linkage<a href=#changing-linkage class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li><code>extern</code> will change a <a href=/wiki/cmsc216/#block-scope>Block Scope</a> variable from no linkage to external</li><li><code>static</code> will change a <a href=/wiki/cmsc216/#file-scope>File Scope</a> variable from external linkage to internal</li></ul><h3 id=storage>Storage<a href=#storage class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>Determines the lifetime of the memory of the variable while the program is executing</li><li>It&rsquo;s still accessible only from within its <a href=/wiki/cmsc216/#scope>Scope</a>, but controls when the value&rsquo;s memory gets destroyed</li></ul><h3 id=const>const<a href=#const class=hanchor arialabel=Anchor>&#8983;</a></h3><h3 id=structures>Structures<a href=#structures class=hanchor arialabel=Anchor>&#8983;</a></h3><h3 id=unions>Unions<a href=#unions class=hanchor arialabel=Anchor>&#8983;</a></h3><p>**</p><h2 id=operators>Operators<a href=#operators class=hanchor arialabel=Anchor>&#8983;</a></h2><h3 id=unary>Unary<a href=#unary class=hanchor arialabel=Anchor>&#8983;</a></h3><h4 id=negation>Negation<a href=#negation class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li><code>-</code></li><li>flips the sign</li></ul><h4 id=increment-decrement>Increment/Decrement<a href=#increment-decrement class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li><code>++</code> / <code>--</code></li><li>Increments/Decrements by 1</li><li>Before the expression computes before substituing the expression</li><li>After expression changes the variable after substitution, so the existing value is used.</li></ul><h4 id=size>Size<a href=#size class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li><code>sizeof</code></li><li>Gets the size in <code>size_t</code> of a given value</li></ul><h4 id=comma>Comma<a href=#comma class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li><code>expr1,exp2</code></li><li>Evaluates its first operand and then the right one, producing the right&rsquo;s output as its own</li></ul><h4 id=indirection>Indirection<a href=#indirection class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li><code>*</code></li><li>Gets the value at the given address</li></ul><h4 id=address>Address<a href=#address class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li><code>&</code></li><li>Gets the address a given value is stored at</li></ul><h3 id=logical>Logical<a href=#logical class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>Both <code>&&</code> and <code>||</code> use short circuit evaluation</li></ul><h3 id=bitshifts>Bitshifts<a href=#bitshifts class=hanchor arialabel=Anchor>&#8983;</a></h3><h4 id=left-shift>Left Shift<a href=#left-shift class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li><code>value &lt;&lt; n</code></li><li>shifts <code>value</code>&rsquo;s bits left by <code>n</code> positions<ul><li>Rightmost bits get 0, leftmost bits get discarded</li></ul></li></ul><h4 id=right-shift>Right Shift<a href=#right-shift class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li><code>value >> n</code></li><li>shifts <code>value</code>&rsquo;s bits right by <code>n</code> positions<ul><li>If unsigned, the leftmost bits get 0</li><li>If signed, whether the leftmost bits get 0 or 1 is implementation dependent</li></ul></li></ul><h3 id=bitwise>Bitwise<a href=#bitwise class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>And (<code>&</code>): Ands two bits</li><li>Or (<code>|</code>): Ors two bits</li><li>Xor (<code>^</code>): Xors two bits</li><li>Complement (<code>~</code>): Negates 1 bit</li></ul><h4 id=masking>Masking<a href=#masking class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li>We can construct masks to select only certain bits from multiple of them</li></ul><h3 id=rvalues-and-lvalues>rvalues and lvalues<a href=#rvalues-and-lvalues class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>rvalues can appear on the right hand side of an assignment</li><li>lvalues can appear on the left hand side of an assignment</li></ul><h3 id=evaluation>Evaluation<a href=#evaluation class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>Order of evaluation goes first by precedence, then associativity, and finally unspecified as long as <code>&&</code>, <code>||</code>, <code>()</code>, <code>?:</code>, and <code>,</code> work</li></ul><h4 id=precedence>Precedence<a href=#precedence class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li>Order of given operators</li></ul><h4 id=associativity>Associativity<a href=#associativity class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li>Whether to operate left to right or left to right</li></ul><h2 id=pointers>Pointers<a href=#pointers class=hanchor arialabel=Anchor>&#8983;</a></h2><ul><li>A pointer is a variable that holds the address of something in memory</li><li>Pointers can be <a href=/wiki/cmsc216/#rvalues-and-lvalues>rvalues and lvalues</a> but addresses can only be rvalues</li><li>Pointer declarations must be initialized</li><li>Functions can return a pointer but you must ensure the variable will not be destroyed after the function leaves</li></ul><h3 id=null-pointer>NULL Pointer<a href=#null-pointer class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>Special values that pointer can have that doesn&rsquo;t point anywhere</li><li>Defined in <a href=/wiki/cmsc216/#stddef>stddef</a></li></ul><h2 id=make>Make<a href=#make class=hanchor arialabel=Anchor>&#8983;</a></h2><ul><li><code>make</code> autobuilds programs by using separate compilation to efficiently only build what&rsquo;s needed using a user defined dependency hierarchy</li><li>A Makefile has multiple rules<ul><li>A rule consits of a target, a dependency list, and a set of actions</li><li>The target is the name/identifier of the rule and it can specifically be built with <code>make target</code></li><li>The dependency list follows the target and a colon and an update to any of these dependency files will cause the target&rsquo;s action(s) to run</li><li>Each action line follows a target line and starts with a tab character. Each action line is run when the target needs to be rebuilt</li></ul></li><li>A dependency will cause the target to be rebuilt if its newer than the target</li><li>An error in a given action line will cause the action lines following it to not run unless the action line starts with a <code>-</code> which will allow actions lines following to continue to run even if the current one fails</li><li>Comments start with a <code>#</code> and lines can be broken onto following ones with a <code>\</code></li><li>Makefiles provide macros that represent a predefined value defined at the start of the makefile and repeatedly used within it<ul><li>They&rsquo;re defined with <code>name=value</code> and used with <code>$(name)</code></li><li><code>CC</code> is the name for the c compiler, and <code>CFLAGS</code> is the name for options to use with the compiler<ul><li>Use these to allow for ease of addition and reading</li><li>Also you don&rsquo;t need <code>CFLAGS</code> when linking</li></ul></li></ul></li><li>Makefiles often have targets that aren&rsquo;t true files, like <code>all</code> and <code>clean</code>, which are phony targets</li></ul><h2 id=dynamic-memory-allocation>Dynamic Memory Allocation<a href=#dynamic-memory-allocation class=hanchor arialabel=Anchor>&#8983;</a></h2><ul><li>Most data in C is stored on the stack, but sometimes we want to store dynamic variables whose size we can&rsquo;t predict at compile time</li><li>Dynamic memory allocation allows us to request memory to use while the program is running</li></ul><h3 id=malloc><code>malloc</code><a href=#malloc class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>malloc allocates space of the given size and returns a pointer to it, without intializing the memory</li><li>returns NULL if error</li></ul><h3 id=free><code>free</code><a href=#free class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>free releases the memory at the pointer</li><li>the pointer must point to the start of dynamically allocated memory</li><li>you must free all memory dynamically allocated if you want to avoid leaks</li><li>free does nothing other than release memory</li><li>free(NULL) does nothing</li></ul><h3 id=calloc><code>calloc</code><a href=#calloc class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>calloc allocates spaces to store <code>num</code> things of each <code>size</code> and initializes all the memory to 0</li><li>returns NULL if an error</li></ul><h3 id=realloc><code>realloc</code><a href=#realloc class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>reallocates dynamically allocated memory at <code>ptr</code> with <code>new_size</code></li><li>Copies space over to the new space if it can&rsquo;t be done in the same current space</li></ul><h2 id=structures-and-pointers>Structures & Pointers<a href=#structures-and-pointers class=hanchor arialabel=Anchor>&#8983;</a></h2><ul><li>Structures can be self-referential by containing a pointer to its structure tag</li><li>Structures can contain each other by using a partial struct declaration (just <code>struct name</code>), declaring the other struct, and then fully defining the partially defined struct</li><li>Function pointers dont need to be deferenced to be called, nor do they need to be set to the address of the function name (the function name itself suffices)</li></ul><h2 id=strings>Strings<a href=#strings class=hanchor arialabel=Anchor>&#8983;</a></h2><ul><li>Strings are character arrays with a terminating <code>NUL</code> byte (which does not count for its length)</li><li><code>strlen(char const *string)</code> returns the length of the string without its terminating <code>NUL</code> byte<ul><li>it returns an unsigned int so a combination of its return values can never be negative</li></ul></li><li>Unrestricted functions<ul><li><code>strcpy(char *dst, char const *src)</code> copies the string from src into dst</li><li><code>strcat(char *dst, char const *src)</code> copies the string in src to the end of dst</li><li><code>strcmp(char const *s1, char const *s2)</code> compares two strings lexicographically</li><li>These functions assume a <code>NUL</code> byte exists and will run until it is found, which may not always be the case</li><li>An equivalent version of each of the functions exists (<code>strncpy</code>, <code>strncat</code>, <code>strncmp</code>) that take an extra length parameter and only go up until there</li><li><code>strchr(char const *str, int ch)</code> searches for a character from the left</li><li><code>strrchr(char const *str, int char)</code> searches for a character from the right</li><li><code>strpbrk(char const *str, char const *group)</code> searches for a group of characters from the left</li><li><code>strstr(char const *s1, char const *s2)</code> searches for a substring</li></ul></li></ul><h2 id=command-line-arguments>Command Line Arguments<a href=#command-line-arguments class=hanchor arialabel=Anchor>&#8983;</a></h2><ul><li><code>main(int argc, char *argv[])</code> is a valid declaration for main<ul><li><code>argc</code> is the number of arguments when called, including the name</li><li><code>argv</code> is that list, with the first being the name, and <code>argv[argc]</code> being NULL</li><li>It&rsquo;s also possible for main to take a third parameter <code>char *envp[]</code>, which is an array of strings in the form <code>KEYWORD=VALUE</code> for all environment variables</li></ul></li></ul><h2 id=the-preprocessor>The Preprocessor<a href=#the-preprocessor class=hanchor arialabel=Anchor>&#8983;</a></h2><ul><li><code>#define</code> defines a constant and the value to replace it with</li><li>Double underscored symbols are already predefined</li><li><code>#define</code> also defines a macro, which is the same thing but it takes parameters<ul><li>When defining a macro, wrap the result and uses of the parameters in parentheses</li></ul></li><li>Macros do complete textual replacement, so statements with side effects may get executed more than once</li><li>Macro substitution is not done in function calls</li><li>Macros can invoke each other</li><li>Conditional compilation<ul><li><code>#if cond</code> will only include the code if cond is true<ul><li>you need an <code>#endif</code>, and optionally an <code>#elif</code> and a <code>#else</code> if wanted</li></ul></li><li><code>defined(NAME)</code> checks if the following symbol is defined</li><li>Nested inclusion<ul><li>Give each headerfile its own symbol, which will only include it once no matter who many times <code>#include</code> is done</li></ul></li><li><code>#undef NAME</code> undefines name</li><li>-D to the compiler will define a symbol</li></ul></li></ul><h2 id=process-control>Process Control<a href=#process-control class=hanchor arialabel=Anchor>&#8983;</a></h2><ul><li><strong>Kernel</strong>: The layer of the OS that is always running and serves as the hardware interface</li><li>Not all programs have privileges, so if they want to do important things they must ask the OS to do it for them through a system call</li><li>Process Table: stores info about each process, page table stores info about each process, and file table stores info abotu files</li><li>Process can be in the states: new, ready, waiting, running, terminated</li><li><strong>Signals</strong>: A message to a process to notify it of en event<ul><li>The <code>kill()</code> system call sends messages, not always <code>SIGKILL</code></li></ul></li><li>Including <code>&lt;err.h></code> gives you functions that properly print errors<ul><li><code>err()</code> prints a given error string and the library explanations and quits</li><li><code>errx()</code> prints a given error string and quits</li></ul></li><li><code>fork()</code><ul><li>Creates a new process and returns a <code>pid_t</code>, which is 0 for the child, >0 (child pid) for the parent, and -1 for an error</li><li>Most things are inherited</li></ul></li><li><code>wait()</code><ul><li>Reaps the next finishing direct child process from the process table</li><li>Passing in a pointer to an int will give you a status</li><li>Using macros like <code>WIFEXITED</code> and <code>WEXITSTATUS</code></li></ul></li><li><code>exec()</code><ul><li>Runs the given programs, and never returns, and the new program replaces the process</li><li>If error, returns -1</li></ul></li></ul><p>:ID: 43947200-ddd3-4794-b144-db11f2fa7dc4</p><h2 id=system-level-i-o>System-Level I/O<a href=#system-level-i-o class=hanchor arialabel=Anchor>&#8983;</a></h2><ul><li>File Descriptors<ul><li>A process-level object that is associated with a given file</li><li>STDIN is fd 0, STDOUT is fd 1, and STDERR is fd 2</li></ul></li><li><code>open(const char *filename, int flags, int mode (optional))</code><ul><li>Opens a file, returning a file descriptor</li></ul></li></ul><h2 id=i-o>I/O<a href=#i-o class=hanchor arialabel=Anchor>&#8983;</a></h2><h2 id=assembly>Assembly<a href=#assembly class=hanchor arialabel=Anchor>&#8983;</a></h2><h3 id=registers>Registers<a href=#registers class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>4 bytes</li><li>Names start with a $</li><li>General purpose registers are <code>$t0</code> through <code>$t9</code></li><li>Using a register in parentheses, like <code>($t0)</code>, means use the address that the register stores<ul><li>Putting a constant before the opening parentheses offsets the address stored by the given amount</li></ul></li><li>Register spilling is when we have too many values to keep only in registers</li></ul><h3 id=system-calls>System Calls<a href=#system-calls class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>Asks the OS to do something</li><li>Done in MIPS by loading a syscall code in <code>$v0</code>, arguments into <code>$a0</code> through <code>$a3</code>, and then the <code>syscall</code> instruction</li></ul><h4 id=syscall-codes>Syscall Codes<a href=#syscall-codes class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li>exit<ul><li>code: 10</li><li>arguments: none</li><li>return value: none</li></ul></li><li>print_int<ul><li>code: 1</li><li>arguments: <code>$a0</code> - the integer to print</li><li>return value: none</li></ul></li><li>print_char<ul><li>code: 11</li><li>arguments: <code>$a0</code> - address of string to print</li><li>return value: none</li></ul></li><li>read_int<ul><li>code: 5</li><li>arguments: none</li><li>return value: <code>$v0</code> - the integer read</li></ul></li><li>read_char<ul><li>code: 12</li><li>arguments: none</li><li>return value; <code>$a0</code> - the character read</li></ul></li></ul><h3 id=directives>Directives<a href=#directives class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>They tell the assembler something about how to assemble the program</li><li><code>.text</code> says that what comes after goes into the text segment</li><li><code>.data</code> says that what comes after goes into the data segment</li><li><code>.word</code> says stores what follows on the current line to successive memory locations as ints</li><li><code>.asciiz</code> says store the contents of the following double-quoted string as a null terminated string</li></ul><h3 id=instructions>Instructions<a href=#instructions class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>A command to run that consists of 3-4 letter code, and then 2-3 registers<ul><li>The first register is always where to put the result</li><li>The third operand can be a literal</li></ul></li></ul><h3 id=labels>Labels<a href=#labels class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>A human-readable alias for a memory address of an instruction/data item</li></ul><h3 id=functions-in-assembly>Functions in Assembly<a href=#functions-in-assembly class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>Store how to get back, jump there, jump back, reset</li></ul><h4 id=stack-frame>Stack Frame<a href=#stack-frame class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li>A set of data that stores information about a called function</li><li><code>$fp</code> points to the first word in the current stack frame</li><li><code>$sp</code> points the first free location just past the stack</li><li>When growing the stack, make sure to leave space for local variables + 8 for <code>$fp</code> and <code>$sp</code></li><li>Make sure to reload registers that you need after a function call</li></ul><ul><li><p>Prologue</p><div class=collapsable-code><input id=657324198 type=checkbox checked>
<label for=657324198><span class=collapsable-code__language>nasm</span>
<span class=collapsable-code__title>MIPS Assembly Function Prologue</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class="language-nasm line-numbers"><code>    sub    $sp, $sp, 8
    sw     $ra, 8($sp)
    sw     $fp, 4($sp)
    add    $fp, $sp, 8
    </code></pre></div></li></ul><ul><li><p>Epilogue</p><div class=collapsable-code><input id=673592841 type=checkbox checked>
<label for=673592841><span class=collapsable-code__language>nasm</span>
<span class=collapsable-code__title>MIPS Assembly Function Epilogue</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class="language-nasm line-numbers"><code>    lw     $ra, 8($sp)
    lw     $fp, 4($sp)
    add    $sp, $sp, 8
    jr     $ra
    </code></pre></div></li></ul><ul><li><p>Parameters + Return Value + Local Variables</p><div class=collapsable-code><input id=528316794 type=checkbox checked>
<label for=528316794><span class=collapsable-code__language>nasm</span>
<span class=collapsable-code__title>Full MIPS Assembly Function Example</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class="language-nasm line-numbers"><code>    main:   li      $sp, 0x7ffffffc # init sp
            li      $t0, 1
            sw      $t0, ($sp)      # put the argument on the stack
            sub     $sp, $sp, 4     # grow the stack
            jal     f               # call the function
            add     $sp, $sp, 4     # pop the arg off
            mov     $t1, $v0        # get the return value
            mov     $a0, $t0        # print it
            mov     $v0, 1
            syscall
            mov     $v0, 10         # exit
            syscall
    f:      sub    $sp, $sp, 12     # grow the stack
            sw     $ra, 12($sp)     # store the ra
            sw     $fp, 8($sp)      # store the fp
            add    $fp, $sp, 12     # set the new fp
            lw     $t0, 4($fp)      # load the argument
            add    $t0, $t0, 1
            sw     $t0, 4($sp)      # store it as a local variable
            mov    $v0, $t0         # set the return value
            lw     $ra, 8($sp)      # get the return address
            lw     $fp, 4($sp)      # get the old frame pointer
            add    $sp, $sp, 12     # decrement the stack
            jr     $ra              # go back
    </code></pre></div></li></ul><h2 id=concurrency>Concurrency<a href=#concurrency class=hanchor arialabel=Anchor>&#8983;</a></h2><ul><li>If it can be active at multiple places, it&rsquo;s concurrent</li><li>Threads are part of the same program and can share data</li><li>To use pthreads in C, use <code>-l</code> with gcc</li></ul><h3 id=threads>Threads<a href=#threads class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>Threads share heap memory, global and static memory, files, and a virtual address space but have their own thread id, runtime stack, and other important registers (stack pointer, etc.)<ul><li>This means they share global variables, static local variables, and dynamically allocated data</li></ul></li></ul><h4 id=int-pthread-create--pthread-t-tid-pthread-attr-t-attr-void--func----void--void-arg><code>int pthread_create(pthread_t *tid, pthread_attr_t *attr, void *(*func)(void *), void *arg)</code><a href=#int-pthread-create--pthread-t-tid-pthread-attr-t-attr-void--func----void--void-arg class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li><code>tid</code> is a pointer that will be filled in with an id</li><li><code>attr</code> is <code>NULL</code></li><li><code>func</code> is the function to execute</li><li><code>arg</code> passes an argument</li><li>0 on success, nonzero on erro</li></ul><h4 id=pthread-t-pthread-self--void><code>pthread_t pthread_self(void)</code><a href=#pthread-t-pthread-self--void class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li>Get&rsquo;s own thread id</li></ul><h4 id=void-pthread-exit--void-retval><code>void pthread_exit(void *retval)</code><a href=#void-pthread-exit--void-retval class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li>Terminates the calling thread, which returns the <code>retval</code></li></ul><h4 id=int-pthread-cancel--pthread-t-tid><code>int pthread_cancel(pthread_t tid)</code><a href=#int-pthread-cancel--pthread-t-tid class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li>Terminates the thread with the given <code>tid</code></li><li>Returns 0 on success, nonzero on error</li></ul><h4 id=int-pthread-join--pthread-t-tid-void-retval><code>int pthread_join(pthread_t tid, void **retval)</code><a href=#int-pthread-join--pthread-t-tid-void-retval class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li>Reaps the given thread and frees its memory usage</li><li>Blocks until termination (if already terminated, instant)</li><li>Returns 0 on success, nonzero on error<ul><li>If success, <code>*retval</code> gets the return value</li></ul></li></ul><h3 id=synchronization>Synchronization<a href=#synchronization class=hanchor arialabel=Anchor>&#8983;</a></h3><ul><li>Force concurrent operations to happen in some relative order</li><li>Code that modifies a shared variable is a critical section</li></ul><h4 id=atomicity>Atomicity<a href=#atomicity class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li>When something starts running by one thread and is not interrupted until it finishes</li></ul><h4 id=semaphore>Semaphore<a href=#semaphore class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li>A special integer counter</li><li>If counter is 0, threads must wait</li><li>If counter is nonzero, threads process and counter is decremented</li><li>Once a thread is done, it tells the semaphore, which then increments the counter</li><li>If a counter becomes nonzero while threads are waiting on it to do so, one of the threads will be picked to run</li></ul><ul><li><p><code>int sem_init(sem_t *sem, 0, unsigned int value)</code></p><ul><li>Intializes the semaphore given to <code>value</code></li><li>0 on success, nonzero on error</li></ul></li></ul><ul><li><p>Wait</p><ul><li>The <code>P</code> operation</li><li>Blocks if counter is 0</li><li>Returns if counter is positive</li><li><a href=/wiki/cmsc216/#atomicity>Atomic</a> operation</li><li><code>int sem_wait(sem_t *sem)</code><ul><li>0 on success, nonzero on error</li></ul></li></ul></li></ul><ul><li><p>Post</p><ul><li>The <code>V</code> operation</li><li>Increments the counter</li><li>Unblocks a random waiting thread if threads are waiting</li><li><a href=/wiki/cmsc216/#atomicity>Atomic</a> operation</li><li><code>int sem_post(sem_t *sem)</code><ul><li>0 on success, nonzero on error</li></ul></li></ul></li></ul><h4 id=mutual-exclusion>Mutual Exclusion<a href=#mutual-exclusion class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li>Only allow a certain number of threads to execute a block of code</li></ul><h4 id=condition-synchronization>Condition Synchronization<a href=#condition-synchronization class=hanchor arialabel=Anchor>&#8983;</a></h4><ul><li>Control the relative order of actions performed by different threads based on some condition</li><li><code>sem_wait</code> and <code>sem_post</code> are usually in different threads</li></ul></div></div></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>©2021-2024 Kandasamy Chokkalingam</span>
<span>:: Based on <a href=https://twitter.com/panr>panr's</a> Terminal theme</aspan></div></div></footer><script src=https://www.kandasamyc.com/assets/main.js></script><script src=https://www.kandasamyc.com/assets/prism.js></script></div></body></html>