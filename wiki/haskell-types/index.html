<!doctype html><html lang=en><head><title>Haskell Types :: Kandasamy Chokkalingam</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Notes on types in Haskell"><meta name=keywords content="Kandasamy Chokkalingam"><meta name=robots content="noodp"><link rel=canonical href=https://www.kandasamyc.com/wiki/haskell-types/><link rel=stylesheet href=https://www.kandasamyc.com/assets/style.css><link rel=stylesheet href=https://www.kandasamyc.com/assets/green.css><link rel=apple-touch-icon href=https://www.kandasamyc.com/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://www.kandasamyc.com/img/favicon/green.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Haskell Types"><meta property="og:description" content="Notes on types in Haskell"><meta property="og:url" content="https://www.kandasamyc.com/wiki/haskell-types/"><meta property="og:site_name" content="Kandasamy Chokkalingam"><meta property="og:image" content="https://www.kandasamyc.com/img/favicon/green.png"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2021-07-28 00:00:00 +0000 UTC"></head><body class=green><div class="container center"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>Kandasamy Chokkalingam</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/>About</a></li><li><a href=/wiki>Wiki</a></li><li><a href=/#contact>Contact</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/>About</a></li><li><a href=/wiki>Wiki</a></li><li><a href=/#contact>Contact</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://www.kandasamyc.com/wiki/haskell-types/>Haskell Types</a></h1><div class=post-meta><span class=post-date>2021-07-28</span>
<span class=post-author>:: [ksam]</span></div><div class=post-content><div><h2 id=custom-data-types>Custom Data Types<a href=#custom-data-types class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Defining custom data types is akin to or C++&rsquo;s or Rust&rsquo;s Structs.</p><p>To define a custom data type use the <code>data</code> keyword.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#66d9ef>data</span> <span style=color:#66d9ef>TypeConstructor</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>ValueConstructor</span> <span style=color:#66d9ef>Argument</span>
</span></span><span style=display:flex><span>                       <span style=color:#66d9ef>deriving</span> (<span style=color:#66d9ef>Typeclass</span>)
</span></span></code></pre></div><ul><li>The <code>TypeConstructor</code> is the name of the type, and use it when writing a type
declaration or signature.</li><li>The <code>ValueConstructor</code> is the keyword to use when constructing a instance of
that type.</li><li>There can be any number of <code>Argument</code> where each is the name of some actual
type.</li><li>New data types can also optionally derive from multiple <a href=#typeclasses>Typeclasses</a>, separated by commas.</li></ul><h2 id=algebraic-data-types>Algebraic Data Types<a href=#algebraic-data-types class=hanchor arialabel=Anchor>&#8983;</a></h2><p>An algebraic data type has more than one value constructor. Each alternative (or
case) represents a possible value of the type constructor. Each alternative can
have different numbers of arguments and different arguments altogether.</p><p>These are well suited to use as enums as well, just make sure to derive from <code>Eq</code> and <code>Show</code>.</p><h2 id=type-synonyms>Type Synonyms<a href=#type-synonyms class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Type synonyms allow for making aliases to other types for specificity. It can
create a shorter name for a more verbose type. It does not declare a new type
like <a href=#custom-data-types>Custom Data Types</a> do.</p><h2 id=typeclasses>Typeclasses<a href=#typeclasses class=hanchor arialabel=Anchor>&#8983;</a></h2><h2 id=record-syntax>Record Syntax<a href=#record-syntax class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Instead of defining a data type with the <code>data</code> keyword like when normally
creating <a href=#custom-data-types>Custom Data Types</a> and having to write individual accessor methods for
each field, Haskell provides record syntax that will automatically create them
for you.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#66d9ef>data</span> <span style=color:#66d9ef>TypeConstructor</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>ValueConstructor</span> {
</span></span><span style=display:flex><span>                                        <span style=color:#66d9ef>ArgumentName</span>  <span style=color:#f92672>::</span> <span style=color:#66d9ef>ArgumentType</span>,
</span></span><span style=display:flex><span>                                        <span style=color:#66d9ef>ArgumentName2</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>ArgumentType2</span>
</span></span><span style=display:flex><span>                                        } <span style=color:#66d9ef>deriving</span> (<span style=color:#66d9ef>Typeclass</span>)
</span></span></code></pre></div><p>With this syntax the functions <code>ArgumentName</code> and <code>ArgumentName2</code>, with types of
<code>TypeConstructor -> ArgumentType</code> and <code>TypeConstructor -> ArgumentType2</code>
respectively, will be created.</p><p>The normal syntax for creating a value of the type still applies, but with
record syntax, you can also alternatively specify field name and value pairs in
a custom order.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>value</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>ValueConstructor</span> {
</span></span><span style=display:flex><span>                         <span style=color:#66d9ef>ArgumentName2</span> <span style=color:#f92672>=</span> val,
</span></span><span style=display:flex><span>                         <span style=color:#66d9ef>ArgumentName</span> <span style=color:#f92672>=</span> val2
</span></span><span style=display:flex><span>                         }
</span></span></code></pre></div><h2 id=parameterized-types>Parameterized Types<a href=#parameterized-types class=hanchor arialabel=Anchor>&#8983;</a></h2></div></div></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>Â©2022 Kandasamy Chokkalingam</span>
<span>:: Based on <a href=https://twitter.com/panr>panr's</a> Terminal theme</aspan></div></div></footer><script src=https://www.kandasamyc.com/assets/main.js></script>
<script src=https://www.kandasamyc.com/assets/prism.js></script></div></body></html>